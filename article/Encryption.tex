% My Encryption Algorithim Article
% Henry J Schmale
% March 3, 2015

\documentclass[12pt]{article}

% Margins
\usepackage[letterpaper]{geometry}
\geometry{
  top    = 1.0in,
  bottom = 1.0in,
  left   = 1.0in,
  right  = 1.0in}

% Font
\usepackage{times}

% Spacing
\setlength{\textheight}{9.5in}

% Math Formulas
\usepackage{mathtools}

% Algorithims and code Formatting
\usepackage[]{algpseudocode}
\usepackage{listings}
\usepackage{color}

% Start of the document
\begin{document}

% TITLE
\title{Hiding an Encrypted Message Inside an Image using
      Standard File Formats}
\author{Henry J Schmale}
\date{March 2015}
\maketitle

% abstract
\begin{abstract}
  The design and implementation of an algorithim to encrypt a message
  and hide it inside of a standard image file. This paper describes
  the implementation of a simple xor rotate cipher, and then gives
  a description on how to encode the output data inside of an image.
  Additionally, this paper will include details of extracting the
  encrypted message from an image, and undoing the enryption on that
  image.
\end{abstract}

% MAIN CONTENT
\section{Introduction}
  Encryption is a powerful tool to protect your information, but standard
  encryption can be insecure if found. Additionally, it can be incriminating
  if found, so that is why hiding the encrypted information is more important
  then ever. This practice is called stenography, and I have developed such
  a system to encrypt a text document, and hide it inside of an image, this
  document describes in detail the processed used to encrypt and hide the
  information inside of a photograph.

  This paper describes the design and implementation of an algorithim to
  hide data inside of a standard image file. 

\section{Encryption and Decryption}
  The encryption used in this system is a simple XOR rotation cipher.
  The cipher uses an n-byte key to encrypt and decrypt the message.
  Along with the use of a rotating key, this a relatively fast and
  secure algorithim, though probably nowhere near as secure as any of
  public-private key algorithims. However, this algorithim was not
  designed with that in mind, this algorithim was designed with the
  thought of protecting a file against a cursory overview.
  
  As this algorithim uses a rotating key to encrypt mesages there
  must be regular pattern to how the key changes. As such the
  change to the key is a simple bit rotation after each use. 
  
  % Equation describing the value of K to use in this iteration
  \begin{equation}
    \label{eq:keyDerive}
    K_i = rightRotate(
        \underbrace{K_i \bmod length(K)}_\text{Value to rotate},
        \underbrace{\frac{i}{length(K)} \bmod (sizeof(type(K)) 
            \times B)}_\text{places}) 
  \end{equation}

  Equation \eqref{eq:keyDerive} describes how to calculate the key value to use
  in iteration \( i \) of the encryption algorithim. It requires the use
  of a bitwise rotate operation so that no data is lost, through the
  replacement by zeros when using standard bitwise shifts. And as zeros
  were introduced into the key, the xor shift would no longer work as
  all the bits would remain the same.

  This algorithim can use an n-bit key as the new key value is
  determined indepently of the length of the key and provides
  facilities for working with various key lengths. As such it can use
  a n-bit key for encryption and decryption.

  The encryption algorithim requires the use of the bitwise xor and
  takes advantage of the speed yielded with an xor opperation, due to
  no carry bits being required, and dedicated circuitry existing on most
  modern processors. Below is a description of the algorithim in detail.

  \subsection{Encrypting a Message}
    This section describes the process of encrypting a message.
    The general process of encrypting a message using an xor rotate
    cipher is quite simple, but it becomes more complex with the
    addition of a rotating key. The general process of encryption
    using an xor rotate cipher is descriped below. 
    
    \begin{figure}[h]
    \begin{algorithmic}[1]
    \For{$i=0; i < length(OriginalMessage); i++$}
      \State $EncryptedMesage_i =
             rotateRight(OriginalMessage_i \oplus Key_{i \bmod length(Key)})$
    \EndFor 
    \end{algorithmic}
    \caption{A Basic XOR rotation cipher}
    \end{figure}

    If there was nothing more than an XOR opperation in this algorithim,
    it would be incredibly easy to use a brute-force attack against.
    However, since a bit rotation was added into the algorithim, there
    are now \(CHAR\_BITS^2\) possible solutions to the message, making
    brute-forcing it, less of an option. However, the key is still
    vurnable to being brute-forced, so modification of the key is also
    required. Yielding, something more like the following.
    
    \begin{figure}[h]
    \begin{algorithmic}[1]
    \For{ $i=0; i < length(OriginalMessage); i++$}
      \State $EncryptedMessage_i =
             rotateRight(OriginalMessage_i \oplus Key_{i \bmod length(Key)})$
      \If{$( i \bmod length(Key) ) \equiv 0$}
        \For{ $j=0;j < length(Key); j++$ }
          \State $Key_j = rotateRight(Key_j)$
        \EndFor
      \EndIf
    \EndFor
    \end{algorithmic}
    \caption{An Improved XOR rotation cipher}
    \end{figure}
    
    As you can see the second example is much more confusing, as it involves
    manipulation of the actual key. As more confusion is better in 
    cryptography the second algorithim is much better. 
    Additionally, the encryption process can be described as a mathmatical
    formula, as seen below.
    
    \begin{figure}[h]
    \begin{equation}
      \label{eq:Encrypt}
      E_{i} = rightRotate(M_{i} \oplus K_{i},   
    \end{equation}
    \caption{Where \( K_i \) is defined as in \eqref{eq:keyDerive}}
    \end{figure}

    \subsubsection{Programming an Encryption Algorithim}
    Now to implement such an algorithim in C++, we need to perform several
    checks before we can even begin. First of all, nulls must be
    checked for, as three parameters are pointers, and can be null. As writing
    to a null pointer would cause a segmentation fault, it must be checked for.
    Therefore, the encryption function should start with a couple of standard
    asserts or macro that does the same thing. Additionally, memory allocation
    sizes must be checked, otherwise the encryption function might write to
    memory that the program hasn't  been allocated, causing another
    segmentation fault. Finally, the encryption key must be copied into
    local memory as the Key is passed by pointer, and can be modified within
    that function and returned via pointer, the encryption key might be used
    in other parts of the program and should be treated as constant memory.
    Therefore there are several checks to be made before even running the
    algorithim.
    
    Additionally, the implemented algorithim must defend against cold-boot
    attacks, so the usage of memory that clears itself after being finished
    with is a must. This is especially important where the encryption key
    was stored. Therefore, a for loop is used to clear the allocated memory
    before the encryption function is returns to the caller.
    
    
    \lstset{language=C++,
            keywordstyle=\color{red},
            basicstyle=\small,
            numbers=left,
            numberstyle=\tiny,
            stepnumber=1}
    \begin{lstlisting}[caption=C++ Encryption Source Code]
void encryptString(const uint8_t *KEY, uint16_t keyLen, uint8_t *instr,
                   uint64_t inlen, uint8_t *outstr, uint64_t outlen){
    assert(inlen <= outlen);
    assert(KEY != NULL);
    assert(instr != NULL);
    assert(outstr != NULL);
    uint8_t *KeyCopy = new uint8_t[keyLen];
    memcpy(KeyCopy, KEY, keyLen);
    for(uint64_t i = 0; i < inlen; i++){
        outstr[i] = instr[i] ^ KeyCopy[i % keyLen];
        outstr[i] = rotateRight(outstr[i], 1);
        if((i % keyLen) == 0){
            for(int j = 0; j < keyLen; j++){
                KeyCopy[j] = rotateRight(KeyCopy[j], 1);
            }
        }
    }
    // Secure Memory
    for(uint16_t i = 0; i < keyLen; i++){
        KeyCopy[i] = 0; // overwrite the key copy
    }
    delete[] KeyCopy;
    //std::cerr << "Finished Encrypting String" << std::endl;
}
    \end{lstlisting}

\subsection{Decrypting a message}
    Decryption is just undoing what has been done to a message, now a
    good cipher will have many differint possibilities to defeat most
    cryptoanalysis methods. In other words, decryption is just inverse
    opperations.
\end{document}
